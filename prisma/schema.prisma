datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            Int      @id @default(autoincrement())
  login         String   @unique
  phone         String   @unique
  fullName      String?
  passwordHash  String
  role          Role     @default(USER)
  priceModifier Float    @default(0)

  // связь «клиент → агент»
  agent        User?    @relation("AgentClients", fields: [agentId], references: [id])
  clients      User[]   @relation("AgentClients")
  agentId      Int?

  telegramId   String?  @unique

  // магазины, в которых он покупатель
  stores       Store[]  
  // магазины, за которые он как агент отвечает
  agentStores  Store[]  @relation("AgentStores")

  // менеджер одного магазина
  storeManaged Store?   @relation("StoreManager")

  // только у агентов заполняем (nullable + unique — ОК)
  maAgentId     String?  @unique

  orders       Order[]
  createdAt    DateTime @default(now())
  favorites    Favorite[]
  priceSyncLogs PriceSyncLog[] 
  productViews  ProductView[] @relation("UserViews")
}

model Store {
  id         Int      @id @default(autoincrement())
  title      String
  address    String

  // владелец (клиент)
  userId     Int
  user       User     @relation(fields: [userId], references: [id])

  // агент, к которому привязан магазин
  agentId    Int?
  agent      User?    @relation("AgentStores", fields: [agentId], references: [id])

  // менеджер этого магазина
  managerId  Int?     @unique
  manager    User?    @relation("StoreManager", fields: [managerId], references: [id])

  // MA ShopID (nullable + unique — ОК)
  maShopId   String? @unique

  orders     Order[]
}

model StockRule {
  id         Int     @id @default(autoincrement())
  priceMax   Int     // верхняя граница цены, ₽  (NULL = ∞)
  stockMax   Int     // верхняя граница остатка  (NULL = ∞)
  label      String  // «Нет в наличии», «Товара мало», …
  color      String  // Tailwind-класс, напр. bg-rose-600
  rank       Int     // порядок применения (меньше — раньше)
}

model Product {
  id            Int       @id @default(autoincrement())
  // текущий «актуальный» внешний hex (MobileAgent). Больше НЕ уникальный
  productId     String?
  // «сырое» имя из внешней БД (для сравнения/синхронизации)
  rawName       String?
  // нормализованное имя (для матчей при смене hex)
  canonicalName String?
  article       String?   @unique
  productVolumeId String?
  name          String
  brand         String?
  type          String?
  volume        Float?    // ранее было String
  degree        Float?
  quantityInBox Int?
  basePrice     Float
  img           String?
  stock         Int       @default(0)
  nonModify     Boolean   @default(false)
  isArchived    Boolean   @default(false)

  bottleType     String?
  countryOfOrigin String?
  region         String?
  whiskyType     String?
  wineColor      String?
  sweetnessLevel String?
  wineType       String?
  giftPackaging  String?
  manufacturer   String?
  excerpt        String?
  rawMaterials   String?
  spirtType      String?
  taste          String?
  tasteProduct   String?
  aromaProduct   String?
  colorProduct   String?
  сombinationsProduct String?
  description    String?

  promos        Promo[]
  orderItems    OrderItem[]
  cartItems     CartItem[]
  createdAt     DateTime  @default(now())
  favoritedBy   Favorite[] 
  views         ProductView[] @relation("ProductViews")

  isNew       Boolean   @default(false)     // ← новинка
  dateAdded   DateTime  @default(now())    // ← когда завели

  @@index([isNew])                          // для выборки «новинки»
  @@index([canonicalName])
  externals   ProductExternalId[]
}

model ProductExternalId {
  id         Int      @id @default(autoincrement())
  productId  Int
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  externalId String   // hex из MobileAgent (источник один, поэтому без поля source)
  isPrimary  Boolean  @default(false)
  syncedAt   DateTime @default(now())

  @@unique([externalId])
  @@index([productId])
}

model ProductView {
  id         Int      @id @default(autoincrement())
  userId     Int
  productId  Int
  viewedAt   DateTime @default(now())

  user       User     @relation("UserViews",    fields: [userId],    references: [id])
  product    Product  @relation("ProductViews", fields: [productId], references: [id])

  @@unique([userId, productId])
  @@index([userId, viewedAt])
}

model PriceSyncLog {
  id           Int      @id @default(autoincrement())
  syncedAt     DateTime @default(now())
  priceChanged Int
  stockChanged Int
  added        Int
  unarchived   Int
  userId       Int
  user         User     @relation(fields: [userId], references: [id])
}

model Promo {
  id         Int      @id @default(autoincrement())
  product    Product  @relation(fields: [productId], references: [id])
  productId  Int
  promoPrice Float
  comment    String?
  expiresAt  DateTime
}

model Favorite {
  id        Int     @id @default(autoincrement())
  userId    Int
  productId Int

  user      User    @relation(fields: [userId],    references: [id])
  product   Product @relation(fields: [productId], references: [id])

  createdAt DateTime @default(now())

  @@unique([userId, productId])        // один товар один раз
  @@index([productId])
}

model Order {
  id           Int         @id @default(autoincrement())
  storeId      Int
  store        Store       @relation(fields: [storeId], references: [id])
  userId       Int         // кто оформил (USER или MANAGER)
  user         User        @relation(fields: [userId], references: [id])

  total        Float
  status       OrderStatus @default(NEW)
  agentComment String?

  items        OrderItem[]
  createdAt    DateTime    @default(now())

  // учёт интеграции с MA
  maInvoiceIdHex String?
  maAppliedAt     DateTime?
  maError         String?

  @@index([status, createdAt])
}

model OrderItem {
  id         Int     @id @default(autoincrement())
  orderId    Int
  order      Order   @relation(fields: [orderId], references: [id])
  productId  Int
  product    Product @relation(fields: [productId], references: [id])
  price      Float
  quantity   Int
}

model Cart {
  id        Int        @id @default(autoincrement())
  userId    Int
  storeId   Int
  items     CartItem[]
  updatedAt DateTime   @updatedAt

  @@unique([userId, storeId])
}

model CartItem {
  id        Int     @id @default(autoincrement())
  cartId    Int
  cart      Cart    @relation(fields: [cartId], references: [id])
  productId Int
  product   Product @relation(fields: [productId], references: [id])
  qty       Int

  @@unique([cartId, productId])
}

enum Role {
  ADMIN
  AGENT
  USER
  MANAGER
}

enum OrderStatus {
  NEW
  DONE
}
